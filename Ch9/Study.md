---
9.1 배열의개요
---

---
** 변수&배열
---
```c
*변수는 오직 하나의 값만 저장할 수 있기 때문에 저장공간인 배열을 사용한다.

*배열의 구조 예시
  int score[10];
  //여기서 int score은 배열의 식별자를 의미하고, 대괄호 내부 숫자는 내부요소의 개수를 뜻한다.
  //인덱스는 10개이므로 0~9까지 존재한다. 즉 저 숫자는 배열의 요소의 개수를 뜻한다.

*배열은 메모리의 연속적인 공간에 저장
  저장된 각 데이터는 요소라고 불린다.
  배열을 통해 연관된 여러 데이터를 묶어서 관리하기 편하다.
```

---
확인문제
---
```
1. 배열을 구성하는 각각의 항목을 (배열요소)라고 한다. (배열요소)에는 번호가 붙어 있는데, 이를 (인덱스)라고 한다.
```


## 9.2 배열 선언과 초기화
---
** 배열의 선언
--
```c
int array[array_size];
int: 배열 요소 자료형, array: 배열명, [array_size(숫자)]: 배열의 크기
```
---

```c
배열의 요소는 메모리 공간에서 모두 연속된 공간에 할당되며, 배열 요소에 접근할 때는 인덱스를 사용한다.
* int array[8]; 배열 요소가 8개인 정수형 배열
* array[3] = 30; 세 번째 인덱스에 30을 저장

*배열의 인덱스에는 변수, 상수, 수식을 사용하여 지정이 가능하다.
int array[8];
int i = 1;
array[i+3] = 40;
--> 4번째 인덱스의 값은 40!

*배열의 인덱스 범위는 0부터 배열크기-1까지다.
범위 초과시 데이터손상, 프로그램의 충돌, 정의되지않은 동작, 보안의 취약성, 디버깅 불가 현상이 일어날 수 있다.
```

---
배열의 초기화
---
```c
배열은 선언과 동시에 초기화가 가능하다.

int array[array_size] = {10, 20, 30, ..., n};
이런식으로 여러개의 값을 쉼표와 중괄호로 초기화가 가능하고, 이는 각 요소에 특정값을 할당하는것과 같으며, 초기화를 하지 않으면 임의의값이 들어가게 되어 로직이 꼬일 수 있다.
```

```c
배열 초기화 시 보통은 인덱스 개수에 맞춰서 적는다.
int arr[3] = {0, 1, 2};

하지만 인덱스 공간 크기 > 초기화 된 값이면
예를들어, 이런식으로 int arr[5] = {1, 2, };
이렇게되면 인덱스 2, 3, 4는 초기화가 안되는데, 초기화가 안된 인덱스 2, 3, 4는 0으로 바뀐다.

또한, 첫번째 인덱스만 0일 경우에는 그 뒤에 나머지 배열요소들도 전부 0으로 초기화한다.

그리고 배열 공간 초기화시 인덱스를 적지 않고 요소만 적어도 자동으로 초기화가 된다.

int num[] = {3, 7, 12};
자동으로 []안에 3이 지정된다.
```

---
배열의 크기 확인법
---
```c
int arrSize = sizeof(score) / sizeof(score[0]); 
//sizeof(score): 배열 전체의 바이트 크기 / sizeof(score[0]): 배열 첫번째 요소 하나의 바이트 크기


int arrByte = arrSize * sizeof(int);
//arrSize: 배열의 요소 개수 * sizeof(int): 자료형 하나가 차지하는 바이트 수

결론: int arrByte = ((sizeof(score) / sizeof(score[0])) * sizeof(int);
```

---
확인문제
---
-> 지협적이라고 교수님께서 skip


---
9.3 배열과 함수
---
```c
배열의 함수 전달(함수의 인자값으로 전달함)
-> 연속된 메모리 공간에 저장되는 배열은 동일한 자료형의 여러 요소로 구성된다.
-> 배열의 값 자주 출력시 사용자 정의 함수로 필요할 때마다 호출시 배열을 효율적으로 처리가 가능하다.
-> 반복문을 사용하여 배열 전체값 출력이 가능하다.

int base[5] = {31, 71, 21, 41, 51};

for (i = 0; i < 5; i++)
  baseNum(base[i]);
  return 0;
}

void baseNum(int x){
  printf("%d", x)
}
이런식으로 배열 내부에 있는 요소값들을 baseNum이라는 변수에 전달후, baseNum을 함수로 호출하여 출력하는 방법으로 사용이 될 수 있다.
```

```c
**배열 요소를 함수에 전달하기

배열은 요소들이 서로 연결되어 있는 형태이다.
예를 들어 첫번째 요소의 주소가 0x12345면 그 첫번째 요소의 자료형의 크기에 따라서 다음 요소의 주소가 결정된다.
예시로, int형인 경우에는 4byte를 차지하므로, 첫번째 요소가 int라면, 그 다음 요소의 주소는 0x12345 + (1 * 4)
즉, 0x12349가 된다고 볼 수 있다.
```

```c
**배열을 매개변수로 사용하는 경우

특정 지역에서 만든 배열의 모든 요소를 다른 함수로 한번에 전달이 가능
배열의 크기 계산이 필요없어서 효율적

double average(int x[]);
  int main(void){
    double avg;
    int arr[5] = { 1, 2, 3, 4, 5};

    avg = average{arr};
    return 0 ;
}

double average(int x[]){ //이런식으로 배열을 매개변수로 사용이 가능하다.
  ...
return(sum);
}

```

---
**확인문제
---

1. (배열)을 함수의 매개변수로 사용하면 배열의 모든 요소를 전달받게 되는데, 이는 (배열)이 첫 번째 주소를 가리키는 포인터로 해석되기 때문에
가능한 일이다.

(중요)2. 다음 함수를 호출하는 코드를 작성하시오. 호출하는 함수의 배열은 int arr[3] = {1, 2, 3};
   ```c
   int array_list(int scores[], int size)
   ```
---
```c
정답
int scores[3] = {1, 2, 3};
//여기가 핵심인데, 원래 배열명은 arr이었지만, scores[]로 호출하라고 해서 배열명을 scores로 바꾸었다.
array_list(scores, 3);
//여기서 scores는 배열의 시작 주소, 3은 배열의 요소 개수를 뜻한다.
scores는 배열의 이름(시작 주소를 가리키는 포인터처럼 작동한다.)
```
---

---
9.4 배열의 활용
---

1. 배열의 최댓값
```c
-> 데이터의 범위를 파악하는데에 중요한 요인이다

int numbers[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
int max = findMax(numbers, 10)
                  //여기서 numbers로 배열의 모든 요소를 한번에 전달 가능하다.
printf("최댓값: %d", max);
}
```

---
2. 배열의 역순 출력 가능
-> 문자열을 뒤집을때 사용 가능, 혹은 최신 데이터부터 보여줄 때 사용 가능
---

---
3. 버블 정렬
---
```
-> 가장 인접한 두 요소부터 가장 멀리있는 요소까지 비교해가면서 위치를 바꾸는 작업을 반복한다.
결과적으로는 최댓값인 요소가 마지막 위치에 자리하는 방식의 정렬이다.
```

---
# 버블 정렬 스왑기법 작성 코드
---
```c
void bubbleSort(int arr[], int x){
  for(int i = 0; i < n-1; i++){
    for(int j = 0; j < n-i-1; j++){
      if(arr[j] > arr[j+1]){
        int temp = arr[j];
        arr[j] = arr[j+1]
        arr[j+1] = temp;
      }
    }
  }
}
-> 코드 설명: i(전체 반복 횟수), 배열의 요소가 n개라면 '최대'n-1번 반복해서 정렬하면 정렬이 끝난다.
  j(두 숫자를 비교할 위치), j < n-i-1(비교대상 인덱스 < 요소개수 - 반복 횟수 - 1
는 매번 비교 범위를 줄이기 위해서 사용(아직 정렬되지 않은 범위를 비교), 추가적으로 1을 안빼면 배열 범위를 넘길 수 있으므로 빼야함

스왑영역 부분은 arr[j]가 그 다음 인덱스인 arr[j+1]보다 클때
arr[j]를 temp에 저장하고 arr[j+1]과 arr[j] 둘중에 작은 값을 앞의 인덱스로 옮기는 작업을 해주고, arr[j+1]을 temp로 바꿔서
arr[j+1]이 arr[j]와 순서가 바뀐다고 간주할 수 있다.
```

---
9.5 2차원배열
---
*기본구조
```c
int table[4][4]
-> [0, 0] ~ [3, 3]이런식으로 출력됨
```

*2차원 배열 초기화
```c
2차원 배열 초기화할때도 중괄호를 사용한다.
하나만 사용해도 초기화가 가능하고, 열의 개수에 따라 초깃값 자동으로 분류

2차원 배열 초기화 시 주의점: 행과 열의 초기홧값의 개수가 일치하지 않으면 논리적인 오류가 발생한다.

그리고 행의 인덱스는 생략가능하지만, 열의 인덱스는 무조건 지정해야한다.
2차원 배열시 행 개수 자동 설정
int arr[][3] = {{1,2,3}, {2,4,6}};
-> 2*3의 배열이 나온다.
```

*2차원 배열에서 함수 전달
-> 배열명을 함수의 매개변수로 지정하면 되고, 1차원 배열을 한 번에 전달하는 방식처럼 내부적으로 주솟값을 전달한다.

---
**확인문제**
---

1. 2차원 배열의 요소에 접근할 때 사용하는 인덱스는 몇 개인가?
   -> (2) 2개
2. 2차원 배열에서 특정 요소에 접근할 때 첫 번째 인덱스와 두 번째 인덱스는 각각 무엇을 의미하는거?
   -> 첫 번째: 행의 번호, 두 번째: 열의 번호

---
9.6 다차원 배열(개념위주로만)
---
```
배열 요소가 또 다른 배열로 구성된 3차원 이상의 배열을 뜻함
다차원 공간 데이터를 처리하거나 다양한 데이터 세트를 묶는 데 주로 사용된다.
```

*기본 구조
```c
int dim[차원 1의 크기][차원 2의 크기][차원 3의 크기]
-> 해당 차원이 가진 요소의 수를 차원의 크기로 본다.
차원1: 면의 개수, 차원2: 행의 개수, 차원3: 열의 개수
```

*다차원 배열 크기 계산법
```c
int dim[2][2][3]
-> 2*2*3*sizeof(int) = 12*4 = 48
배열의 자료형에 따라서 크기가 상이함
```

---
**확인 문제**
---
```
1. 다음 중 3차원 배열을 이루는 면, 행, 열에 대한 설명으로 옳은 것은 무엇인가?
   -> (3) 면은 배열의 두께, 열은 배열의 세로 방향을 나타낸다.

   *행은 가로방향
```





























