# 3.1 개념

## 변수의 개념

* **변수**: 프로그램 실행 중 데이터를 저장하고 참조하거나 수정하기 위해 사용하는 식별자
* 변수 선언 시 \*\*RAM(메모리)\*\*에 자료형 크기만큼 공간 할당
* 변수는 **항상 상단에서 선언**해야 하며, **초기값을 할당**하는 초기화 작업도 필요함

```c
int num = 0;
double decimal = 3.145;
```

## 변수명 작성 규칙

* 언더바(`_`) 사용 가능
* 첫 글자는 숫자로 시작할 수 없음
* 대소문자 구분함
* 변수명에 공백 불가
* 예약어 사용 금지
* 변수명이 전부 대문자일 경우 **상수처럼 사용**하는 것이 관례

---

## 확인문제 3.1

1. 변수 초기화는 변수를 선언하면서 **초기값**을 변수에 할당하는 것을 의미한다.
2. 변수가 메모리를 사용했는지 명확하지 않으면 **가비지 값**이 저장되어 있을 수 있다.
3. 변수명 관례 중 **카멜형**은 각 단어의 첫 글자를 대문자/소문자로 구분하고, **스네이크형**은 언더바로 단어를 구분한다.
4. 정수를 지정하는 변수 선언:

```c
int number = 0;
printf("정수를 입력하세요: ");
scanf("%d", &number);
```

---

# 3.2 개념

## 자료형의 종류

* **정수형**: `short (2B)`, `int (4B)`, `long (4B)`, `long long (8B)`
* **실수형**: `float (4B)`, `double (8B)`, `long double (8B 이상)`
* **문자형**: `char (1B)`, `char[n]` (문자 크기만큼)

## 특수 자료형

* `unsigned`: 부호 없이 **0 이상의 정수만 표현**
* `sizeof`: 변수나 자료형의 크기를 **바이트 단위**로 알려줌

```c
sizeof(변수명); // OK
sizeof(int);     // OK
```

## 오류 유형

* **오버플로우**: 자료형 범위를 초과한 값을 저장할 때 발생
* **언더플로우**: 유효 범위보다 작은 값이 저장될 때 발생
* **롤오버**: 값이 최대/최소값을 넘어가면 시작점으로 되돌아감

### 예시

```c
int mk1 = -2147483648LL; // long long 값을 int에 저장 → 언더플로우가 발생
int 자료형이 저장할 수 있는 범위를 넘어섰기 때문에(정확히는 범위보다 작은수여서)

```

---

## 확인문제 3.2

1. `short`에는 `signed short`와 `unsigned short`가 있다.
2. `long long` 자료형은 8바이트 크기를 가진다.
3. 변수에 자료형 유효 범위를 넘는 값을 저장하면 → **언더플로우** 발생
4. 실수형 종류:

   * `float`: 약 6\~7자리 정확도 (4B)
   * `double`: 약 15\~16자리 정확도 (8B)
   * `long double`: 18자리 이상 (8B 이상)
5. C언어에서 **double형이 기본 실수형**이다.
6. 정수 나눗셈 문제 해결 예시:

```c
float result = 10.0 / 3; // 또는 10 / 3.0
```

> 실수와 정수를 연산하면 결과는 실수형이 됨

---

# 3.3 개념

## 상수의 개념

* **상수**: 프로그램 내에서 **고정된 값**을 나타내는 식별자
* 종류: 정수형, 실수형, 문자형, 문자열 상수

### 표기법

* 문자형 상수: `'A'`, `'a'`, `'0'`, `'$'`
* 문자열 상수: `"ABC"`

### 정수형 상수 출력

```c
printf("%d", 10);   // 10진수
printf("%x", 0x1A);  // 16진수
printf("%o", 012);   // 8진수
```

### 실수형 상수

* `float`: 32비트 → 부호(1) + 지수(8) + 가수(23)
* `double`: 64비트 → 부호(1) + 지수(11) + 가수(52)

```c
float fscore = 589.734f;
double dscore = 589.456;
```

## 기호 상수 정의 방법

* `#define` 사용:

```c
#define PI 3.14
```

* `const` 키워드 사용:

```c
const double PI = 3.14;
```

> 둘 다 **하단에서 값 변경 불가** (변경 시 컴파일 에러)

## 상수 사용 예시

```c
const int ABC = 123;
if (value > ABC) { ... }
```

> 매직넘버를 상수화하여 의미 명확화

---

## 확인문제 3.3

1. 문자형 상수는 `'' (작은따옴표)`로 감싼다.
2. 기호 상수 정의 방법: `#define`, `const 전역변수`

---

# 3.4 개념

## 자료형 변환의 정의

* 한 자료형의 데이터를 다른 자료형으로 변환하는 것
* 예시:

```c
int a = 5, b = 3;
float c = a / b;  // 결과는 1.0 (정수 나눗셈)
```

* 해결 방법:

```c
float c = 5.0 / 3;  // 결과: 1.666...
```

---

## 형 변환 종류

### 자동 형 변환 (암시적)

* 작은 자료형 → 큰 자료형으로 변환됨
* 예시:

```c
int a = 10;
float b = 3.14;
float result = a + b;  // 결과: float

float와 int가 메모리 크기가 같음에도 불구하고 float형으로 변환되는 이유는
float형이 int형보다 정밀한 데이터타입이기 때문이다.

```

### 명시적 형 변환 (캐스팅)

```c
float f = 2.5;
int i = (int)f;  // 결과: 2
```

---

## 확인문제 3.4

1. **자동 형 변환**: C 컴파일러가 자료형을 자동으로 변환함
2. **명시적 형 변환**: 프로그래머가 강제로 자료형 변환 지정함
3. 다음 코드의 결과:

```c
float f = 3.5;
int i = (int)f;
printf("%d", i); // 결과: 3
```

---
