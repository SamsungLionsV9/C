3.1 개념

변수
-> 컴퓨터 프로그램이 실행되는 동안 데이터를 저장하고 그 데이터를 참조하거나 수정하기 위해 사용하는 식별자를 의미

변수 선언시 메모리에 공간이 할당되며, 그 메모리 위치에 데이터를 저장함
변수는 자료형의 크기만큼 램(RAM)에 공간을 할당받음

변수는 항상 상단에서 선언해주어야함.
초기값을 할당하는 변수 초기화 작업도 필요.
예) int num = 0;
    double decimal = 3.145;

* 변수명 작성시 유의사항
1. 언더바 사용가능
2. 첫 글자는 숫자로 시작 불가
3. 대문자와 소문자 구분
4. 변수명 중간에 공백 사용불가
5. 예약어 사용불가

  *추가적으로 변수명이 전부 대문자일시 상수와 같은 기능을한다.

  3.1 확인문제

1. 변수 초기화는 변수를 선언하면서 (초기값)을 변수에 할당하는 것을 의미한다.
2. 어떤 프로그램의 변수가 메모리를 사용했는지 모르기 때문에 메모리가 깨끗하게 정리되지 않아 (가비지값)이 저장되어 있을 수 있다.
3. 변수명 관례중 (카멜형)은 각 단어의 첫 글자를 대문자 또는 소문자로 표기하고, (스네이크형)은 각 단어를 언더바로 구분한다.

4. 정수를 지정하는 변수 number를 선언하는 코드를 작성
int number = 0;
printf("정수를 입력하세요: ");
scanf("%d", &number);


3.2 개념


자료형에는 정수형, 실수형, 문자형 3가지가 있음

정수형 -  short(2byte), int(4byte), long(4byte), long long(8byte)
실수형 -  float(4byte), double(8byte), long double(8byte)
문자형 - char(1byte), char[n](문자 크기만큼)

논리오류: 변수 선언시 자료형과 저장되는 값이 범위가 괴리감이 들시 생기는 현상을 의미한다.

*unsigned 정수값의 의미
-> 최소값을 0으로 고정하여 무조건 양수만 나오는 형식이다.

short: 대략 5자리수 3만대
int, long: 대략 21억대
long long: 뭐... 엄청크다

만약 이 자료형에 맞지않는 값이 들어가게 된다면 언더/오버플로우가 발생한다.

*정수형 자료에서 sizeof 연산자
-> 주어진 변수나 자료형의 크기를 바이트 단위로 알린다.
크기는 컴파일하면 알수있다.

sizeof(피연산자); -> 자료형 변수, 상수도 사용이 가능
sizeof(변수명); -> 자료형 사용 불가


오버플로우: 선언된 변수 자료형의 범위를 초과하는 값을 저장할 떄 발생하는 현상
언더플로우: 유효 범위보다 작은 값이 대입될 때 발생하는 현상

*int 자료형에서의 언더플로우 예시

int mk1 = -2147483648LL;
여기서 원래 LL이 붙어있으면 long long 형태임을 알수있는데, 하지만 mk1을 int형으로 저장했으니
long long형에서 int타입으로 전환이된다.

*롤오버: 특정한 범위의 한계를 초과 -> 다시 시작점으로 돌아가는 현상(정수형 언더 오버플로애서 주로 발생)
예) -2147483648(1차이로 언더플로) -> +2147483647 이런식으로... 부호가 바뀌고 최대값으로 바뀐다.

3.2 확인문제
1. 2바이트 정수형 short에는 (signed)short와 (unsigned)short가 있다.
2. 변수의 자료형을 long long으로 선언했을 때 할당되는 메모리 저장 공간의 크기는 (8byte)이다.
3. C언어에서는 변수에 선언한 자료형이 정상적으로 처리하는 유효 범위의 최솟값보다 더 작은 값이 대입되면 이 현상이 발생
-> (3)언더플로


*실수형 종류
float(6~7자리), double(15~16자리), long double(18자리 이상)
더블부터는 8바이트를 차지한다. 1바이트 = 4비트

C언어에서는 double형이 기본형이다.

실수형 나눗셈중 주의점:
예를 들어 10을 3으로 나누면 정상적으로는 3.3333이 나와야하는데
하지만 C언어에서 단순히 정수 10을 정수3으로 나누면 정답은 정수3이 나온다.
이를 해결하려면 어떻게 해야할까?
-> 10이나 3을 실수형으로 수정해준다 10.0 or 3.0
그 상태에서 /연산을 진행하면 3.3333이런식으로 결과가 나온다.

여기서 유추 가능한점은, 실수로 계산해야 결과도 실수가 나온다는것

확인문제
1. (float)은 단정밀도 부동 소수점 수를 저장하는데 사용되는 자료형이다.
2. (double)은 배정밀도 부동 소수점 수를 저장하는 데 사용되는 자료형이다.
3. (long double)은 double형보다 더 큰 범위와 정밀도의 부동 소수점 수를 저장하는 데 사용되는 자료형이다.

*문자형(단일 문자를 저장)
기본적으로 문자 한개당 1바이트를 차지하는것을 원칙으로 한다.
예시로 알파벳 A를 변수에 저장할때
C언어에서는 이 알파벳 문자를 아스키코드 형태로 변환해서 넣는다.
A:65, a:97이고 대문자와 소문자의 아스키코드 값은 원칙상 32차이가 난다.

확인문제

1. 자료형의 종류 중 문자형에 대한 설명으로 옳은 것은?
   -> (3) 문자형은 단일 문자를 저장할 때 사용한다.
   because, 문자 하나 당 1바이트를 원칙으로 하기 때문에 사실상 단일 문자 저장이 목적이다.

2. 아스키코드는 (7비트)비트로 모든 알파벳을 표현 할 수 있다.
   -> 총 128가지의 문자를 표현가능하므로 2^7 ->7비트이다.

3.3 상수의 개념
프로그램에서는 고정된 값을 나타내는 식별자이다. 한 번  정의하면 유지되는 값이다.
정수형 상수, 실수형 상수, 문자형 상수, 문자열 상수 이렇게 4가지가있다.

문자형 상수는 ''로 표기하고, 문자열 상수는 ""로 표기한다.

정수형 상수의 종류
10진수: ("%d\n", 10진수);
16진수: ("%x\n", 16진수);
8진수: ("%o\n", 8진수);
2진수: ("%d\n", 2진수);

실수형 상수(float) -> 32비트 부동 소수점 형식
fscore = 589.734f;

비트 자릿수 구성은 부호비트(1비트)+지수 부분(8비트)+가수 부분(23비트)

실수형 상수(double) -> 64비트 부동 소수점 형식
dscore = 589.456; (float와 다르게 별도의 알파벳을 붙히지 않음)

비트 자릿수 구성은 부호비트(1비트)+지수 부분(11비트)+가수 부분(52비트)

확인문제
1. float형 상수는 (32비트 부동 소수점)형식으로 표현되는 실숫값이다.
2. double형 상수는 (64비트 부동 소수점)형식으로 표현되는 실숫값이다.


*문자형 상수
1. 알파벳 대문자: 'A'
2. 알파벳 소문자: 'a'
3. 숫자: '0'
4. 특수문자: '$'


*기호상수의 개념
상수는 전처리기 부분에 define으로 정의가 가능하다(#define PI 3.14) +상수인 변수는 전부 대문자로 구성
-> 이걸 사용한 상태에서 하단에서 값 변경 시도시 문법에러가 뜬다.

const로 전역변수 설정
const double PI = 3.14 
이 방법 역시 메인함수 상단에 지정해줘야하고, 일부 지역함수 내에서 값 변경을 시도하면 컴파일 에러가 발생한다.

-> 상수는 하단에서 재정의를 할수없다는것이 핵심


상수 사용 예시

const int ABC = 123;
if(value > ABC)            이렇게 사용하면 상수(숫자)의 의미가 명확해지기 때문에 코드가 더 편하다.
                            한마디로 매직넘버를 미리 상수화 시킨다고 보면 된다.
{
    ///
}

*확인문제
1. 프로그램에서 고정된 문자를 나타내는 데 사용되는 문자형 상수는 ('' 작은 따옴표)로 감싼다.
2. 기호 상수를 정의하는 방법에는 (#define)지시문을 사용하는 방법과 (전역변수 const)명령어를 사용하는 방법이 있다.

3.4 개념
자료형 변환의 정의
-> 어떤 자료형의 데이터를 다른 자료형으로 변환하는 과정을 의미한다.

예시로 
int a = 5;
int b = 3;
float c = a/b;

하지만 c는?
5 / 3 = 1.000000이런식으로 나옴

아까 위에서 얘기했듯이
int형인 a나 b를 5.0, 3.0 이런식으로 최소한 하나는 바꿔줘야
제대로 결과가 출력됨.

1. 자동 형 변환
byte -> short -> int -> long -> float -> double
오른쪽으로 갈 수록 자료형이커진다.

자료형 크기의 연산법: 작은것 | 큰것 -> 큰것 

예시로 int형 a = 10괴 float형 b = 3.14가 있는데
이 둘을 서로 연산하면 float형이 int형보다 크기가 크기 때문에
연산 결과는 float형태로 13.14가 나오는것을 의미한다.

2. 명시적 형 변환
int  i = 10;
float f = 2.5;
int result = (int)f * i;
->기존에 float형이었던 f가 int형으로 명시적 형 변환이 일어나게되면 f가 int형으로 변환된다.(2.5 -> 2)로 간주


*확인문제
1. (자동 형 변환)은 C컴파일러가 자동으로 자료형을 변환하는 방식이다.
2. (명시적 형 변환)은 프로그래머가 직접 자료형을 변환하는 방식이다.

3. 출력되는 값 구하기
   float f = 3.5;
   int = i;
   i = (int)f;

   ->(4) 3

   왜냐하면 int형으로 명시적 형 변환이 발생하였기 때문이다.


























































   








