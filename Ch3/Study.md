3.1 개념

변수
-> 컴퓨터 프로그램이 실행되는 동안 데이터를 저장하고 그 데이터를 참조하거나 수정하기 위해 사용하는 식별자를 의미

변수 선언시 메모리에 공간이 할당되며, 그 메모리 위치에 데이터를 저장함
변수는 자료형의 크기만큼 램(RAM)에 공간을 할당받음

변수는 항상 상단에서 선언해주어야함.
초기값을 할당하는 변수 초기화 작업도 필요.
예) int num = 0;
    double decimal = 3.145;

* 변수명 작성시 유의사항
1. 언더바 사용가능
2. 첫 글자는 숫자로 시작 불가
3. 대문자와 소문자 구분
4. 변수명 중간에 공백 사용불가
5. 예약어 사용불가

  *추가적으로 변수명이 전부 대문자일시 상수와 같은 기능을한다.

  3.1 확인문제

1. 변수 초기화는 변수를 선언하면서 (초기값)을 변수에 할당하는 것을 의미한다.
2. 어떤 프로그램의 변수가 메모리를 사용했는지 모르기 때문에 메모리가 깨끗하게 정리되지 않아 (가비지값)이 저장되어 있을 수 있다.
3. 변수명 관례중 (카멜형)은 각 단어의 첫 글자를 대문자 또는 소문자로 표기하고, (스네이크형)은 각 단어를 언더바로 구분한다.

4. 정수를 지정하는 변수 number를 선언하는 코드를 작성
int number = 0;
printf("정수를 입력하세요: ");
scanf("%d", &number);


3.2 개념


자료형에는 정수형, 실수형, 문자형 3가지가 있음

정수형 -  short(2byte), int(4byte), long(4byte), long long(8byte)
실수형 -  float(4byte), double(8byte), long double(8byte)
문자형 - char(1byte), char[n](문자 크기만큼)

논리오류: 변수 선언시 자료형과 저장되는 값이 범위가 괴리감이 들시 생기는 현상을 의미한다.

*unsigned 정수값의 의미
-> 최소값을 0으로 고정하여 무조건 양수만 나오는 형식이다.

short: 대략 5자리수 3만대
int, long: 대략 21억대
long long: 뭐... 엄청크다

만약 이 자료형에 맞지않는 값이 들어가게 된다면 언더/오버플로우가 발생한다.

*정수형 자료에서 sizeof 연산자
-> 주어진 변수나 자료형의 크기를 바이트 단위로 알린다.
크기는 컴파일하면 알수있다.

sizeof(피연산자); -> 자료형 변수, 상수도 사용이 가능
sizeof(변수명); -> 자료형 사용 불가


오버플로우: 선언된 변수 자료형의 범위를 초과하는 값을 저장할 떄 발생하는 현상
언더플로우: 유효 범위보다 작은 값이 대입될 때 발생하는 현상

*int 자료형에서의 언더플로우 예시

int mk1 = -2147483648LL;
여기서 원래 LL이 붙어있으면 long long 형태임을 알수있는데, 하지만 mk1을 int형으로 저장했으니
long long형에서 int타입으로 전환이된다.

*롤오버: 특정한 범위의 한계를 초과 -> 다시 시작점으로 돌아가는 현상(정수형 언더 오버플로애서 주로 발생)
예) -2147483648(1차이로 언더플로) -> +2147483647 이런식으로... 부호가 바뀌고 최대값으로 바뀐다.

3.2 확인문제
1. 2바이트 정수형 short에는 (signed)short와 (unsigned)short가 있다.
2. 변수의 자료형을 long long으로 선언했을 때 할당되는 메모리 저장 공간의 크기는 (8byte)이다.
3. C언어에서는 변수에 선언한 자료형이 정상적으로 처리하는 유효 범위의 최솟값보다 더 작은 값이 대입되면 이 현상이 발생
-> (3)언더플로















   








